{"version":3,"sources":["components/shared-components/ChartWidget/Top3LineChat.js","components/shared-components/ChartWidget/FrequencySpectrumChart.js","views/app-views/machine-and-sensor/machine-details/graphType.js"],"names":["TopLineChart","_ref","series","title","label","formattedSeries","map","point","index","x","y","Number","sortedPoints","filter","isNaN","sort","a","b","slice","colors","data","name","options","chart","type","zoom","enabled","autoScaleYaxis","animations","markers","size","dataLabels","yaxis","labels","formatter","val","Math","round","text","style","fontSize","fontWeight","stroke","curve","width","xaxis","min","p","max","value","show","tickAmount","tooltip","annotations","points","marker","fillColor","strokeColor","radius","borderColor","offsetY","color","background","columns","render","record","_jsx","height","borderRadius","backgroundColor","dataIndex","key","freq","toFixed","amplitude","children","_jsxs","display","gap","Card","flex","ReactApexChart","textAlign","marginTop","Table","dataSource","pagination","rowKey","FrequencySpectrumChart","frequencyData","optimizedData","yMin","yMax","xMin","xMax","useMemo","Array","isArray","length","validPoints","xValues","yValues","topPeaks","significantPoints","significantIds","Set","bucketSize","buckets","has","bucketIndex","floor","push","sampledPoints","Object","values","bucketPoints","reduce","current","Boolean","chartOptions","toolbar","tools","download","selection","zoomin","zoomout","pan","reset","opacity","strokeWidth","toExponential","logarithmic","forceNiceScale","shared","intersect","followCursor","grid","lines","strokeDashArray","seriesData","GraphType","id","graphType","deviceId","bin","xAxis","yAxis","useParams","setX","useState","setY","z","setZ","setFrequencyData","fileType","setFileType","setShow","loading","setLoading","error","setError","useEffect","tempBin","split","temp","fetchSensorData","async","response","axiosInstance","get","console","log","success","frequencyDomain","frequencies","i","timeDomain","rawData","subSeries","item","message","moment","format","_Fragment"],"mappings":"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","file":"static/js/58.b93df21c.chunk.js","sourcesContent":["import { Card, Table, Tag } from 'antd';\r\nimport moment from 'moment';\r\nimport React from 'react';\r\nimport ReactApexChart from 'react-apexcharts';\r\n\r\nfunction TopLineChart({ series, title, label }) {\r\n    // Convert `y` to a number and `x` to timestamp\r\n    let formattedSeries = series.map((point,index) => ({\r\n        x:  point.x,\r\n        y: Number(point.y) // Ensure `y` is a number\r\n    }));\r\n\r\n    // Sort and get the top 3 points\r\n    const sortedPoints = series\r\n        .filter(point => !isNaN(point.y))\r\n        .sort((a, b) => b.y - a.y)\r\n        .slice(0, 3);\r\n\r\n    const colors = ['#FF0000', '#00FF00', '#0000FF']; // Red, Green, Blue\r\n\r\n    const data = {\r\n        series: [\r\n            {\r\n                name: 'Amplitude',\r\n                data: formattedSeries,\r\n            },\r\n        ],\r\n        options: {\r\n            chart: {\r\n                type: 'line',\r\n                zoom: {\r\n                    enabled: true,\r\n                    type: 'x',\r\n                    autoScaleYaxis: true,\r\n                },\r\n\r\n                    animations: {\r\n                      enabled: false\r\n                    },\r\n                    markers: {\r\n                        size: 0\r\n                     }\r\n                 \r\n                  \r\n            },\r\n            dataLabels: {\r\n                enabled: false,\r\n            },\r\n            yaxis: {\r\n                labels: {\r\n                    formatter: function (val) {\r\n                        return !isNaN(val) ? Math.round(val) : 'N/A'; // Round y value to nearest integer\r\n                    },\r\n                },\r\n                title: {\r\n                    text: 'Amplitude',\r\n                    style: {\r\n                      fontSize: '14px',\r\n                      fontWeight: 'normal'\r\n                    }\r\n                  },\r\n            },\r\n            stroke: {\r\n                curve: 'straight',\r\n                width: 1,\r\n            },\r\n            xaxis: {\r\n                type: 'numeric', // Numeric type for x-axis\r\n                min: Math.min(...formattedSeries.map(p => p.x)), // Set min value based on x\r\n                max: Math.max(...formattedSeries.map(p => p.x)), // Set max value based on x\r\n                labels: {\r\n                    formatter: function (value) {\r\n                        return Math.round(value); // Round x value to nearest integer\r\n                    },\r\n                    show: true,\r\n                },\r\n                tickAmount: 6,\r\n                title: {\r\n                    text: 'Frequency (Hz)',\r\n                    style: {\r\n                      fontSize: '14px',\r\n                      fontWeight: 'normal'\r\n                    }\r\n                  }\r\n            },\r\n            tooltip: {\r\n                x: {\r\n                    formatter: (val) => `Frequency #${Math.round(val)}`, // Display whole number in tooltip\r\n                },\r\n                y:{\r\n                    formatter: (val) => `${(val)}` // Display whole number in tooltip\r\n                }\r\n            },\r\n            annotations: {\r\n                points: sortedPoints.map((point, index) => ({\r\n                    x: point.x,\r\n                    y: point.y,\r\n                    marker: {\r\n                        size: 6,\r\n                        fillColor: colors[index],\r\n                        strokeColor: '#000000',\r\n                        radius: 2,\r\n                    },\r\n                    label: {\r\n                        text: `#${index + 1}: ${Math.round(point.y)}`, // Round annotation to nearest integer\r\n                        borderColor: '#000',\r\n                        offsetY: 0,\r\n                        style: {\r\n                            color: '#fff',\r\n                            background: colors[index],\r\n                        },\r\n                    },\r\n                })),\r\n            },\r\n        },\r\n    };\r\n    \r\n    \r\n    // Table Columns with Colors\r\n    const columns = [\r\n        {\r\n            render:(text, record, index) => <div style={{\r\n                width: '10px',\r\n                height: '10px',\r\n                borderRadius: '50%',\r\n                backgroundColor: colors[index],\r\n            }} ></div>,\r\n        },\r\n        // {\r\n        //     title: 'Time',\r\n        //     dataIndex: 'x',\r\n        //     key: 'time',\r\n        //     render: (time) => moment(time).format('DD-MM-YYYY hh:mm A'),\r\n        // },\r\n        {\r\n            title: 'Frequency (Hz)',\r\n            dataIndex: 'x',\r\n            key: 'point',\r\n            render: (freq) => freq.toFixed(2),\r\n            \r\n        },\r\n        {\r\n            title: 'Amplitude',\r\n            dataIndex: 'y',\r\n            key: 'amplitude',\r\n            render: (amplitude, record, index) => (\r\n               <div style={{ fontWeight: 'bold' }}>\r\n                    {amplitude}\r\n                </div>\r\n            ),\r\n        },\r\n    ];\r\n\r\n    return (\r\n        <div style={{ display: 'flex', gap: '20px' }}>\r\n            <Card style={{ flex: 1 }}>\r\n                <div style={{ fontWeight: 'bold', fontSize: '17px', color: '#000000' }}>\r\n                    {title}\r\n                </div>\r\n                <ReactApexChart options={data.options} series={data.series} type=\"line\" height={370} />\r\n                <div style={{ fontWeight: 'bold', fontSize: '12px', color: '#72849A', textAlign: 'center', marginTop: '10px' }}>\r\n                    {label}\r\n                </div>\r\n            </Card>\r\n\r\n            {/* Table for Top 3 Amplitudes */}\r\n            <Card style={{ width: '20%' }}>\r\n                <Table\r\n                    dataSource={sortedPoints}\r\n                    columns={columns}\r\n                    pagination={false}\r\n                    size=\"small\"\r\n                    rowKey=\"x\"\r\n                />\r\n            </Card>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default TopLineChart;\r\n","import { Card, Table } from 'antd';\r\nimport React, { useMemo } from 'react';\r\nimport ReactApexChart from 'react-apexcharts';\r\n\r\nfunction FrequencySpectrumChart({ frequencyData = [], title = \"Amplitude Spectrum\" }) {\r\n  // Calculate data for chart with useMemo to prevent recalculation on re-renders\r\n  const {\r\n    optimizedData,\r\n    sortedPoints,\r\n    yMin,\r\n    yMax,\r\n    xMin,\r\n    xMax\r\n  } = useMemo(() => {\r\n    // Ensure frequencyData is valid\r\n    if (!Array.isArray(frequencyData) || frequencyData.length === 0) {\r\n      return {\r\n        optimizedData: [],\r\n        sortedPoints: [],\r\n        yMin: 1e+0,\r\n        yMax: 1e+5,\r\n        xMin: 0,\r\n        xMax: 4e+4\r\n      };\r\n    }\r\n\r\n    // Filter out invalid points\r\n    const validPoints = frequencyData.filter(point => \r\n      point && !isNaN(point.x) && !isNaN(point.y) && point.y > 0\r\n    );\r\n    \r\n    // Calculate min/max for axes\r\n    let xValues = validPoints.map(point => point.x);\r\n    let yValues = validPoints.map(point => point.y);\r\n    \r\n    const xMin = xValues.length ? Math.max(0, Math.min(...xValues)) : 0;\r\n    const xMax = xValues.length ? Math.max(...xValues) * 1.05 : 4e+4;\r\n    const yMin = yValues.length ? Math.max(1e-16, Math.min(...yValues) * 0.1) : 1e+0;\r\n    const yMax = yValues.length ? Math.max(...yValues) * 10 : 1e+5;\r\n    \r\n    // Get top 3 peaks\r\n    const topPeaks = [...validPoints]\r\n      .sort((a, b) => b.y - a.y)\r\n      .slice(0, 3);\r\n      \r\n    // Data optimization for large datasets\r\n    let optimizedData = validPoints;\r\n    \r\n    // If we have more than 5000 points, downsample\r\n    if (validPoints.length > 5000) {\r\n      // Keep all significant peaks and downsample the rest\r\n      // First identify significant points (top 100 by amplitude)\r\n      const significantPoints = [...validPoints]\r\n        .sort((a, b) => b.y - a.y)\r\n        .slice(0, 100);\r\n      \r\n      const significantIds = new Set(significantPoints.map(p => p.x));\r\n      \r\n      // Create buckets for downsampling (divide x-axis into 2000 segments)\r\n      const bucketSize = (xMax - xMin) / 2000;\r\n      const buckets = {};\r\n      \r\n      // Sort the remaining points into buckets\r\n      for (const point of validPoints) {\r\n        // Always keep significant points\r\n        if (significantIds.has(point.x)) {\r\n          continue;\r\n        }\r\n        \r\n        // Put the rest in buckets\r\n        const bucketIndex = Math.floor((point.x - xMin) / bucketSize);\r\n        if (!buckets[bucketIndex]) {\r\n          buckets[bucketIndex] = [];\r\n        }\r\n        buckets[bucketIndex].push(point);\r\n      }\r\n      \r\n      // For each bucket, keep the point with maximum amplitude\r\n      const sampledPoints = Object.values(buckets).map(bucketPoints => {\r\n        if (bucketPoints.length === 0) return null;\r\n        return bucketPoints.reduce((max, current) => \r\n          current.y > max.y ? current : max, bucketPoints[0]);\r\n      }).filter(Boolean);\r\n      \r\n      // Combine significant points with sampled points\r\n      optimizedData = [...significantPoints, ...sampledPoints];\r\n    }\r\n    \r\n    return {\r\n      optimizedData,\r\n      sortedPoints: topPeaks,\r\n      yMin,\r\n      yMax,\r\n      xMin,\r\n      xMax\r\n    };\r\n  }, [frequencyData]);\r\n\r\n  const colors = ['#FF0000', '#00FF00', '#0000FF']; \r\n\r\n  // Build chart options with optimized settings\r\n  const chartOptions = {\r\n    chart: {\r\n      type: 'scatter',\r\n      zoom: {\r\n        enabled: true,\r\n        type: 'xy',\r\n      },\r\n      animations: {\r\n        enabled: false\r\n      },\r\n      toolbar: {\r\n        show: true,\r\n        tools: {\r\n          download: true,\r\n          selection: true,\r\n          zoom: true,\r\n          zoomin: true,\r\n          zoomout: true,\r\n          pan: true,\r\n          reset: true\r\n        }\r\n      },\r\n      background: '#FFFFFF',\r\n    },\r\n    dataLabels: {\r\n      enabled: false,\r\n    },\r\n    markers: {\r\n      size: 2,\r\n      opacity: 0.8,\r\n      strokeWidth: 0\r\n    },\r\n    yaxis: {\r\n      type: 'log',\r\n      min: yMin,\r\n      max: yMax,\r\n      labels: {\r\n        formatter: function (val) {\r\n          return val.toExponential(0);\r\n        },\r\n      },\r\n      title: {\r\n        text: 'Amplitude',\r\n        style: {\r\n          fontSize: '14px',\r\n          fontWeight: 'normal'\r\n        }\r\n      },\r\n      logarithmic: true,\r\n      forceNiceScale: true,\r\n    },\r\n    xaxis: {\r\n      type: 'numeric',\r\n      min: xMin,\r\n      max: xMax,\r\n      tickAmount: 8,\r\n      labels: {\r\n        formatter: function (val) {\r\n          return val.toExponential(0);\r\n        },\r\n      },\r\n      title: {\r\n        text: 'Frequency (Hz)',\r\n        style: {\r\n          fontSize: '14px',\r\n          fontWeight: 'normal'\r\n        }\r\n      }\r\n    },\r\n    tooltip: {\r\n      x: {\r\n        formatter: (val) => `${val.toFixed(2)} Hz`,\r\n      },\r\n      y: {\r\n        formatter: (val) => `${val.toExponential(2)}`,\r\n      },\r\n      shared: false,\r\n      intersect: true,\r\n      followCursor: false,\r\n    },\r\n    grid: {\r\n      xaxis: {\r\n        lines: {\r\n          show: true\r\n        }\r\n      },\r\n      yaxis: {\r\n        lines: {\r\n          show: true\r\n        }\r\n      },\r\n      borderColor: '#E0E0E0',\r\n      strokeDashArray: 0,\r\n    },\r\n    annotations: {\r\n      points: sortedPoints.map((point, index) => ({\r\n        x: point.x,\r\n        y: point.y,\r\n        marker: {\r\n          size: 6,\r\n          fillColor: colors[index],\r\n          strokeColor: '#000000',\r\n          radius: 2,\r\n        },\r\n        label: {\r\n          text: `#${index + 1}: ${point.y.toExponential(2)}`,\r\n          borderColor: '#000',\r\n          offsetY: 0,\r\n          style: {\r\n            color: '#fff',\r\n            background: colors[index],\r\n          },\r\n        },\r\n      })),\r\n    },\r\n  };\r\n\r\n  // Table Columns with Colors\r\n  const columns = [\r\n    {\r\n      render: (text, record, index) => (\r\n        <div\r\n          style={{\r\n            width: '10px',\r\n            height: '10px',\r\n            borderRadius: '50%',\r\n            backgroundColor: colors[index],\r\n          }}\r\n        ></div>\r\n      ),\r\n    },\r\n    {\r\n      title: 'Frequency (Hz)',\r\n      dataIndex: 'x',\r\n      key: 'frequency',\r\n      render: (freq) => freq.toFixed(2),\r\n    },\r\n    {\r\n      title: 'Amplitude',\r\n      dataIndex: 'y',\r\n      key: 'amplitude',\r\n      render: (amplitude) => (\r\n        <div style={{ fontWeight: 'bold' }}>\r\n          {amplitude.toExponential(2)}\r\n        </div>\r\n      ),\r\n    },\r\n  ];\r\n\r\n  // Memoize series data to prevent unnecessary recalculations\r\n  const seriesData = useMemo(() => [{\r\n    name: 'Amplitude',\r\n    data: optimizedData,\r\n  }], [optimizedData]);\r\n\r\n  return (\r\n    <div style={{ display: 'flex', gap: '20px' }}>\r\n      <Card style={{ flex: 1 }}>\r\n        <div style={{ fontWeight: 'bold', fontSize: '17px', color: '#000000' }}>\r\n          {title}\r\n        </div>\r\n        <ReactApexChart\r\n          options={chartOptions}\r\n          series={seriesData}\r\n          type=\"scatter\"\r\n          height={370}\r\n        />\r\n      </Card>\r\n\r\n      {/* Table for Top 3 Peaks */}\r\n      {sortedPoints.length > 0 && (\r\n        <Card style={{ width: '20%' }}>\r\n          <Table\r\n            dataSource={sortedPoints}\r\n            columns={columns}\r\n            pagination={false}\r\n            size=\"small\"\r\n            rowKey={(record, index) => `peak-${index}`}\r\n          />\r\n        </Card>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default FrequencySpectrumChart;","import { Card } from 'antd';\r\nimport { axiosInstance } from 'App';\r\nimport TopLineChart from 'components/shared-components/ChartWidget/Top3LineChat';\r\nimport FrequencySpectrumChart from 'components/shared-components/ChartWidget/FrequencySpectrumChart'; // Import the new component\r\nimport moment from 'moment';\r\nimport React, { useEffect, useState } from 'react';\r\nimport { useParams } from 'react-router-dom/cjs/react-router-dom';\r\n\r\nfunction GraphType() {\r\n  const { id, graphType, deviceId, bin, xAxis, yAxis } = useParams();\r\n\r\n  const [x, setX] = useState([]);\r\n  const [y, setY] = useState([]);\r\n  const [z, setZ] = useState([]);\r\n  const [frequencyData, setFrequencyData] = useState([]); // New state for frequency data\r\n  const [fileType, setFileType] = useState(''); // To track if it's a single_axis or 3_axis file\r\n  const [show, setShow] = useState(false);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(null);\r\n\r\n  useEffect(() => {\r\n    if (bin) {\r\n      const tempBin = bin.split('.')[0];\r\n      const temp = tempBin.split('_')[tempBin.split('_').length - 1];\r\n      if (temp == 1) {\r\n        setShow(false);\r\n      } else {\r\n        setShow(true);\r\n      }\r\n    }\r\n    fetchSensorData();\r\n  }, [bin]);\r\n\r\n  const fetchSensorData = async () => {\r\n    try {\r\n      setLoading(true);\r\n      const response = await axiosInstance.get(`api/getDataFromPythonScript?fileName=${bin}`);\r\n      console.log('API Response:', response.data);\r\n\r\n      // Check if the response has the new data structure\r\n      if (response.data.success) {\r\n        // Set the file type\r\n        setFileType(response.data.fileType || 'three_axis');\r\n        if (response.data.fileType === 'single_axis') {\r\n          // If it's a single axis file, set the frequency data\r\n          setFrequencyData(response.data.frequencyDomain.frequencies.map((point, i) => ({\r\n            x: i + 1,\r\n            y: point\r\n          })));\r\n\r\n          setZ(response.data.timeDomain.data.map((point, i) => ({\r\n            x: i + 1,\r\n            y: point\r\n          })))\r\n\r\n        } else {\r\n          const rawData = response.data.timeDomain.subSeries;\r\n\r\n          setX(() => {\r\n            const data = rawData[0].data.map((item, index) => {\r\n              return {\r\n                x: index + 1,\r\n                y: item\r\n              }\r\n            })\r\n            return data\r\n          })\r\n\r\n          setY(() => {\r\n            const data = rawData[1].data.map((item, index) => {\r\n              return {\r\n                x: index + 1,\r\n                y: item\r\n              }\r\n            })\r\n            return data\r\n          })\r\n\r\n\r\n          setZ(() => {\r\n            const data = rawData[2].data.map((item, index) => {\r\n              return {\r\n                x: index + 1,\r\n                y: item\r\n              }\r\n            })\r\n            return data\r\n          })\r\n\r\n        }\r\n\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('Error fetching data:', error);\r\n      setError('Error fetching data: ' + error.message);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  if (loading) return <div>Loading data...</div>;\r\n  if (error) return <div>Error: {error}</div>;\r\n\r\n  return (\r\n    <div>\r\n      <Card>\r\n        <div style={{\r\n          fontWeight: 'bold',\r\n          color: '#000000',\r\n        }}>\r\n          {bin}\r\n        </div>\r\n        <div>\r\n          X: {moment(xAxis).format('DD-MM-YYYY HH:mm:ss')}\r\n        </div>\r\n        <div>\r\n          Y: {yAxis}\r\n        </div>\r\n      </Card>\r\n\r\n      {/* Frequency Spectrum Chart */}\r\n      {frequencyData && frequencyData.length > 0 && (\r\n        <FrequencySpectrumChart\r\n          frequencyData={frequencyData}\r\n          title=\"Amplitude Spectrum\"\r\n        />\r\n      )}\r\n\r\n      {/* Time Domain Charts */}\r\n      {show && (\r\n        <>\r\n          <TopLineChart graphType={graphType} title={\"Amplitude X\"} series={x} />\r\n          <TopLineChart graphType={graphType} title={\"Amplitude Y\"} series={y} />\r\n        </>\r\n      )}\r\n      <TopLineChart graphType={graphType} title={\"Amplitude Z\"} series={z} />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default GraphType;"],"sourceRoot":""}